## 购物车

### 页面的设计

在购物车里,我们需要展示些什么东西呢?

那首先就是我们的商品了.商品需要展示些什么属性呢?

我们要展示 商品的图片,名称,规格,以及单价,

我们还需要些什么功能呢,或者说我们还需要做些什么呢?

购物车里的商品的数量是可以增加或者减少的,所以我们需要一个步进器,让它去提供这一功能

最后就剩下我们的结算功能了,结算功能的话,可以给它一个固定的容器去存放,结算功能有什么呢,一个是计算总价,也就是所谓的合计,另一个就是跳转到结算页面的按钮.大致的流程就是这样的,接下来我们去控制器里瞧一瞧

### 控制器流程

先定义state数据

定义一个数组

state.items = [ ] 用于接收从cartitem中获取的数据

定义一个总价

state.totalPrice = 0

定义一个函数 去加载数据并刷新价格

调用系统接口   从cartitem表中查询数据   

参数为 用户siteuser_id = "<<siteuser_id>>"

定义局部变量 totalPrice = 0

将获取到的数组进行循环

在循环中我们添加条件去进一步限制

我们要进行 商品是否被选择 进行判断

之后在进行计算总价

totalPrice +=(item.data.product_price * item.data.product_quantity)

做完这些操作之后呢,就是我们的赋值了

将我们之前所定义好的 state.items = 我们获取数据的action.objects

state.totalPrice  = 我们之前定义的局部变量 totalPrice



我们定义的有修改产品数量和产品是否被选中的功能 价格发生变化

我们定义一个函数 作用就是 修改产品数量

我们先调用系统接口 去打印一下我们所要修改的产品数量,data

参数为event

之后我们要调用修改数据系统接口 在cartitem表中 

参数为 

数据表, 数据行ID(注意这里传的是id)

这里的表为 cartitem   

数据行ID 为  event.context.eventData.id

修改数据的字段为

产品的总价和产品的数量

产品的总价price(数据表里面的字段)为

event.data * event.context.eventData.data.product_price

产品数量　product_quantity为

event.data

之后我们检验一下是否会报错，调用系统接口　校验错误状态并返回

这里可以修改返回错误提示　

最后就是调用我们加载产品的函数　重新渲染一下



完成数量的增加或减少，我们之后完成的就是产品是否被选中

如果被选中　则会进行总价的计算，如果不被选择　则不会进行总价的计算



定义函数　作用为　产品的选择与取消

这个我们也一样　先打印一下event这个变量，看看它里面所包含的内容

然和我们调用修改数据接口

参数为　selected = !event.context.eventData.data.selected

之后检查一下是否报错并将报错信息　返回

调用系统　校验错误状态并返回

最后我们调用加载函数　重新渲染一下



点击结算按钮

调用系统接口　校验条件false返回　　

检查的值为　　state.totalPrice >0 总价是否大于０

然后调用我们的系统接口　跳转到结算页面





所遇错误：

在修改选择函数中

点击修改选择，会报出　no_update_permission

这个错误原因是　因为没有权限

我们权限该怎么设呢？在数据库的表结构中　点击显示权限，我们改为所有人可用，这下就可以成功执行了

在修改数量时

添加或减少数量，会报出value_object_parse_data_error

这个错误意思大概是　值对象解析数据错误

这个原因是在哪呢，它说的意思是解析错误　也就是我们传过去的参数不对，所以我们去找我们修改数据传参的那个地方，看一下参数是否写错，之后去找的时候发现　数据行ID写错，原本应该是

event.context.eventdata.id

通过id去找到对象，

我写成了　event.context.eventdata

缺少了id　，在解析的时候　它找不到id所以才会报解析数据错误

今天的发现：

这个是页面上可以看到，而左边框架定义看不到

今天发现了一个新的小功能，子模块中还可以添加子模块，当我们看一页面的时候，发现它应该有三个子模块，可结果，它却只显示一个或两个子模块，那么最后我们该如何去找这个子模块呢，我们去子模块里面找

还有一种，与上面相反，是定义的时候定义了三个子模块，在显示时，却只渲染了两个子模块，剩下那个子模块去哪里了．一般这种情况，通常是因为你在定义容器的时候，定义了条件容器，而子模块也放在了条件容器下，所以条件如果不满足的话，子模块是不会被渲染出来的，所以我们找不到







## 结算页

### 控制器流程：

初始化数据，

定义状态数据

state.items = [　]　定义数组　一会接收赋值

state.totalPrice = 0  定义一个总价，默认　为０

定义收货地址id跟收货地址列表，定义支付id，和支付方式列表，支付方式id

然后在定义一个config对象，定义表单数据　formdata

最后定义一个表单校验数据

我们先来定义函数　用于加载数据和刷新价格

还是我们之前的方法，调用系统接口查询表　cartitem

参数为

siteuser_id

判断是否获取到用户的购物车

之后就是打印一下看看获取到了的数据是否正确

如果正确我们就将这个获取数据的动作也就是我们之前调用的接口函数这个action的objects赋值给我们最早定义的items

然后我们在声明一个局部变量totalPrice= 0,一会给它赋值

将获取到数组，进行数组循环

循环内容是　先判断　产品是否被选，如果被选则进入下一步计算总价

总价加等于商品数量＊商品单价

（这是在循环里面）所以可以这样直接些，否则你得在其后面＋上一次计算后的总价

最后我们将我们所获得到的总价赋给我最初定义的总价

然后就是加载收货地址列表　支付方式列表

两个内容都差不多，先写获取收货地址列表

我们获取收货地址列表调用小程序里面的选择Dapi接口调用

点击参数，里面由接口分类，选择收货地址接口，还有接口动作，采用异步用户获取收货地址．之后就是将获取到数据的action的objects赋值给我们定义的state.addressbooklist，然后我们判断我们获取到数据的action.objects的长度是否为０，如果不为０的话，将其第一项元素的id赋值给我们定义好的收货地址id state.addressbookId

加载支付方式列表与之相似

然后就是更新收货地址和更新支付方式．

直接给之前定义好的state赋值就行，

然和就是更新订单选项校验数据，这个也是跟上面那两个一样，直接给赋值就ok了．



我们所调用的云函数　也就是下单接口

首先打印一下传来的event　有哪些数据，

然后开启数据库事务，因为要下单，与数据库新建数据有关系，所以要开启事务，

首先获取我们用户id，然后校验一下是否获取到我们的用户id,如果没有获得，提示未登录,然后调用系统接口去获取用户的购物车数据，m

如果获取的total_count为０，则购物车为空．

从数据库中计算价格并与前段价格比较．

定义一个总价totalPrice = 0, orderitems = [ ]

然和对之前获取到的数据进行数组循环，

循环时先判断商品是否被选，如果被选则进行下一步操作，

然后计算我们的总价加等于产品价格乘以产品数量

然后将获取到的数据用系统数组方法添加到我们之前定义好的orderitems中

如果我们计算的价格不等于前段页面的价格　则返回计算错误



问题：

1. 表单数据如何添加，也就是如何设置．

   全局配置config其里面有表单数据

   调用的时候

   可以使用写好原子组件　自定义表单

   给其中的表单数据

   value 绑定值是我们定义的formdata

   form表单是我们　在config里面的data下的订单选项表单

2. 下单时报错，总价没有定义

   定义的时候单词写错

3. 前段价格和后端价格不一致

4. [[ com slide/13717/my_address_wjs.wjs selectedaddressid = 'checkData.addressbook_id' callback = 'selectAddressCallback' ]]

   这句话的意思，就是调用这个组件里面的引用wjs文件

   参数：

   selectedaddressid ＝我们之前定义好的checkData.addressbook.id

   callback 为我们的